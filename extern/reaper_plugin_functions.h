#ifndef _REAPER_PLUGIN_FUNCTIONS_H_
#define _REAPER_PLUGIN_FUNCTIONS_H_

// REAPER API functions
// Generated by REAPER v3.1415

// Note: the C++ pure virtual interfaces used require the MSVC-compatible C++ ABI on Win32.  Sorry, mingw users.
//
// Reaper extensions: see http://www.cockos.com/reaper/sdk/plugin/plugin.php and reaper_plugin.h.
// The API functions in this header can be retrieved using reaper_plugin_info_t.GetFunc().
//
// VST plugins: see http://www.cockos.com/reaper/sdk/vst/vst_ext.php
// The API functions in this header can be retrieved using audioMasterCallback.
//
// Because the API is dynamic, callers should never assume a function exists.
// Check that a non-NULL function pointer was returned before using it.

#ifndef _LICE_H
typedef unsigned int LICE_pixel;
typedef unsigned char LICE_pixel_chan;
class LICE_IBitmap;
class LICE_IFont;
#endif

class WDL_VirtualWnd_BGCfg;

// easiest to include reaper_plugin.h before reaper_plugin_functions.h in your application code.
// if not, you may need to edit this path.
#ifndef _REAPER_PLUGIN_H_
#include "reaper_plugin.h"
#endif

#ifndef REAPERAPI_DECL
#define REAPERAPI_DECL extern
#endif

// __mergesort is a stable sorting function with an API similar to qsort().
// HOWEVER, it requires some temporary space, equal to the size of the data being sorted, so you can pass it as the last parameter,
// or NULL and it will allocate and free space internally.
REAPERAPI_DECL void (*__mergesort)(void* base, size_t nmemb, size_t size, int (*cmpfunc)(const void*,const void*), void* tmpspace);

// menuidstr is some unique identifying string
// menuname is for main menus only (displayed in a menu bar somewhere), NULL otherwise
// kbdsecname is the name of the KbdSectionInfo registered by this plugin, or NULL for the main actions section
REAPERAPI_DECL bool (*AddCustomizableMenu)(const char* menuidstr, const char* menuname, const char* kbdsecname, bool addtomainmenu);

// Add an Extensions main menu, which the extension can populate/modify with plugin_register("hookcustommenu")
REAPERAPI_DECL bool (*AddExtensionsMainMenu)();

// creates a new media item.
REAPERAPI_DECL MediaItem* (*AddMediaItemToTrack)(MediaTrack* tr);

// Returns the index of the created marker/region, or -1 on failure. Supply wantidx>=0 if you want a particular index number, but you'll get a different index number a region and wantidx is already in use.
REAPERAPI_DECL int (*AddProjectMarker)(ReaProject* proj, bool isrgn, double pos, double rgnend, const char* name, int wantidx);

// creates a new take in an item
REAPERAPI_DECL MediaItem_Take* (*AddTakeToMediaItem)(MediaItem* item);

// forceset=0,doupd=true,centermode=-1 for default
REAPERAPI_DECL void (*adjustZoom)(double amt, int forceset, bool doupd, int centermode);

REAPERAPI_DECL void (*APITest)();

// is in pre-buffer? threadsafe
REAPERAPI_DECL int (*Audio_IsPreBuffer)();

// is audio running at all? threadsafe
REAPERAPI_DECL int (*Audio_IsRunning)();

// return >0 on success
REAPERAPI_DECL int (*Audio_RegHardwareHook)(bool isAdd, audio_hook_register_t* reg);

// -1 = bypass all if not all bypassed,otherwise unbypass all
REAPERAPI_DECL void (*BypassFxAllTracks)(int bypass);

REAPERAPI_DECL int (*CalculatePeaks)(PCM_source_transfer_t* srcBlock, PCM_source_peaktransfer_t* pksBlock);

REAPERAPI_DECL void (*ClearAllRecArmed)();

// resets the global peak caches
REAPERAPI_DECL void (*ClearPeakCache)();

// count the number of items in the project (proj=0 for active project)
REAPERAPI_DECL int (*CountMediaItems)(ReaProject* proj);

// count the number of selected items in the project (proj=0 for active project)
REAPERAPI_DECL int (*CountSelectedMediaItems)(ReaProject* proj);

// count the number of selected tracks in the project (proj=0 for active project)
REAPERAPI_DECL int (*CountSelectedTracks)(ReaProject* proj);

// count the number of takes in the item
REAPERAPI_DECL int (*CountTakes)(MediaItem* item);

// see GetTrackEnvelope
REAPERAPI_DECL int (*CountTrackEnvelopes)(MediaTrack* track);

// count the number of items in the track
REAPERAPI_DECL int (*CountTrackMediaItems)(MediaTrack* track);

// count the number of tracks in the project (proj=0 for active project)
REAPERAPI_DECL int (*CountTracks)(ReaProject* proj);

REAPERAPI_DECL midi_Input* (*CreateMIDIInput)(int dev);

REAPERAPI_DECL midi_Output* (*CreateMIDIOutput)(int dev, bool streamMode, int* msoffset100);

// call this to force flushing of the undo states after using CSurf_On*Change()
REAPERAPI_DECL void (*CSurf_FlushUndo)(bool force);

REAPERAPI_DECL bool (*CSurf_GetTouchState)(MediaTrack* trackid, int isPan);

REAPERAPI_DECL void (*CSurf_GoEnd)();

REAPERAPI_DECL void (*CSurf_GoStart)();

REAPERAPI_DECL int (*CSurf_NumTracks)(bool mcpView);

REAPERAPI_DECL void (*CSurf_OnArrow)(int whichdir, bool wantzoom);

REAPERAPI_DECL void (*CSurf_OnFwd)(int seekplay);

REAPERAPI_DECL bool (*CSurf_OnFXChange)(MediaTrack* trackid, int en);

REAPERAPI_DECL bool (*CSurf_OnMuteChange)(MediaTrack* trackid, int mute);

REAPERAPI_DECL double (*CSurf_OnPanChange)(MediaTrack* trackid, double pan, bool relative);

REAPERAPI_DECL double (*CSurf_OnPanChangeEx)(MediaTrack* trackid, double pan, bool relative, bool allowGang);

REAPERAPI_DECL void (*CSurf_OnPlay)();

REAPERAPI_DECL bool (*CSurf_OnRecArmChange)(MediaTrack* trackid, int recarm);

REAPERAPI_DECL void (*CSurf_OnRecord)();

REAPERAPI_DECL void (*CSurf_OnRew)(int seekplay);

REAPERAPI_DECL bool (*CSurf_OnSelectedChange)(MediaTrack* trackid, int selected);

REAPERAPI_DECL bool (*CSurf_OnSoloChange)(MediaTrack* trackid, int solo);

REAPERAPI_DECL void (*CSurf_OnStop)();

REAPERAPI_DECL void (*CSurf_OnTrackSelection)(MediaTrack* trackid);

REAPERAPI_DECL double (*CSurf_OnVolumeChange)(MediaTrack* trackid, double volume, bool relative);

REAPERAPI_DECL double (*CSurf_OnVolumeChangeEx)(MediaTrack* trackid, double volume, bool relative, bool allowGang);

REAPERAPI_DECL void (*CSurf_ResetAllCachedVolPanStates)();

REAPERAPI_DECL void (*CSurf_ScrubAmt)(double amt);

REAPERAPI_DECL void (*CSurf_SetAutoMode)(int mode, IReaperControlSurface* ignoresurf);

REAPERAPI_DECL void (*CSurf_SetPlayState)(bool play, bool pause, bool rec, IReaperControlSurface* ignoresurf);

REAPERAPI_DECL void (*CSurf_SetRepeatState)(bool rep, IReaperControlSurface* ignoresurf);

REAPERAPI_DECL void (*CSurf_SetSurfaceMute)(MediaTrack* trackid, bool mute, IReaperControlSurface* ignoresurf);

REAPERAPI_DECL void (*CSurf_SetSurfacePan)(MediaTrack* trackid, double pan, IReaperControlSurface* ignoresurf);

REAPERAPI_DECL void (*CSurf_SetSurfaceRecArm)(MediaTrack* trackid, bool recarm, IReaperControlSurface* ignoresurf);

REAPERAPI_DECL void (*CSurf_SetSurfaceSelected)(MediaTrack* trackid, bool selected, IReaperControlSurface* ignoresurf);

REAPERAPI_DECL void (*CSurf_SetSurfaceSolo)(MediaTrack* trackid, bool solo, IReaperControlSurface* ignoresurf);

REAPERAPI_DECL void (*CSurf_SetSurfaceVolume)(MediaTrack* trackid, double volume, IReaperControlSurface* ignoresurf);

REAPERAPI_DECL void (*CSurf_SetTrackListChange)();

REAPERAPI_DECL MediaTrack* (*CSurf_TrackFromID)(int idx, bool mcpView);

REAPERAPI_DECL int (*CSurf_TrackToID)(MediaTrack* track, bool mcpView);

REAPERAPI_DECL double (*DB2SLIDER)(double x);

// Delete a marker.  proj==NULL for the active project.
REAPERAPI_DECL bool (*DeleteProjectMarker)(void* proj, int markrgnindexnumber, bool isrgn);

// deletes a track
REAPERAPI_DECL void (*DeleteTrack)(MediaTrack* tr);

REAPERAPI_DECL bool (*DeleteTrackMediaItem)(MediaTrack* tr, MediaItem* it);

REAPERAPI_DECL void (*DockWindowActivate)(HWND hwnd);

REAPERAPI_DECL void (*DockWindowAdd)(HWND hwnd, char* name, int pos, bool allowShow);

REAPERAPI_DECL void (*DockWindowRemove)(HWND hwnd);

// Populate destmenu with all the entries and submenus found in srcmenu
REAPERAPI_DECL bool (*DuplicateMenu)(void* srcmenu, void* destmenu);

// call with a saved window rect for your window and it'll correct any positioning info.
REAPERAPI_DECL void (*EnsureNotCompletelyOffscreen)(RECT* r);

// returns FALSE when done,sets out to NULL if a mode is currently unsupported
REAPERAPI_DECL bool (*EnumPitchShiftModes)(int idx, char** out);

REAPERAPI_DECL const char* (*EnumPitchShiftSubModes)(int idx, int submode);

REAPERAPI_DECL int (*EnumProjectMarkers)(int idx, bool* isrgn, double* pos, double* rgnend, char** name, int* markrgnindexnumber);

REAPERAPI_DECL int (*EnumProjectMarkers2)(void* proj, int idx, bool* isrgn, double* pos, double* rgnend, char** name, int* markrgnindexnumber);

// idx=-1 for current project,projfn can be NULL if not interested in filename
REAPERAPI_DECL void* (*EnumProjects)(int idx, char* projfn, int projfnlen);

// returns false if there are no plugins on the track that support MIDI programs,or if all programs have been enumerated
REAPERAPI_DECL bool (*EnumTrackMIDIProgramNames)(int track, int programNumber, char* programName, int maxnamelen);

// returns false if there are no plugins on the track that support MIDI programs,or if all programs have been enumerated
REAPERAPI_DECL bool (*EnumTrackMIDIProgramNamesEx)(void* proj, void* track, int programNumber, char* programName, int maxnamelen);

// time formatting mode overrides: -1=proj default.
// 0=time
// 1=measures:beats + time
// 2=measures:beats
// 3=seconds
// 4=samples
// 5=h:m:s:f
REAPERAPI_DECL void (*format_timestr)(double tpos, char* buf, int buflen);

// time formatting mode overrides: -1=proj default.
// 0=time
// 1=measures:beats + time
// 2=measures:beats
// 3=seconds
// 4=samples
// 5=h:m:s:f
// offset is start of where the length will be calculated from
REAPERAPI_DECL void (*format_timestr_len)(double tpos, char* buf, int buflen, double offset, int modeoverride);

// time formatting mode overrides: -1=proj default.
// 0=time
// 1=measures:beats + time
// 2=measures:beats
// 3=seconds
// 4=samples
// 5=h:m:s:f
REAPERAPI_DECL void (*format_timestr_pos)(double tpos, char* buf, int buflen, int modeoverride);

// free heap memory returned from a Reaper API function
REAPERAPI_DECL void (*FreeHeapPtr)(void* ptr);

REAPERAPI_DECL void (*genGuid)(GUID* g);

REAPERAPI_DECL void* (*get_config_var)(const char* name, int* szout);

REAPERAPI_DECL const char* (*get_ini_file)();

// get the active take in this item
REAPERAPI_DECL MediaItem_Take* (*GetActiveTake)(MediaItem* item);

// deprecated?
REAPERAPI_DECL INT_PTR (*GetColorTheme)(int idx, int defval);

// returns the whole color theme (icontheme.h) and the size
REAPERAPI_DECL void* (*GetColorThemeStruct)(int* sz);

// gets context menus. submenu 0:trackctl, 1:mediaitems, 2:ruler, 3:empty track area
REAPERAPI_DECL HMENU (*GetContextMenu)(int idx);

// edit cursor position
REAPERAPI_DECL double (*GetCursorPosition)();

// edit cursor position
REAPERAPI_DECL double (*GetCursorPositionEx)(void* proj);

REAPERAPI_DECL bool (*GetEnvelopeName)(TrackEnvelope* env, char* buf, int maxlen);

// returns path of REAPER.exe (not including EXE),i.e. C:\Program Files\REAPER
REAPERAPI_DECL const char* (*GetExePath)();

// returns pixels/second
REAPERAPI_DECL double (*GetHZoomLevel)();

// returns a named icontheme entry
REAPERAPI_DECL void* (*GetIconThemePointer)(const char* name);

// returns the whole icon theme (icontheme.h) and the size
REAPERAPI_DECL void* (*GetIconThemeStruct)(int* sz);

REAPERAPI_DECL const char* (*GetInputChannelName)(int idx);

REAPERAPI_DECL void* (*GetItemProjectContext)(MediaItem* item);

REAPERAPI_DECL MediaTrack* (*GetLastTouchedTrack)();

REAPERAPI_DECL HWND (*GetMainHwnd)();

// &1=master mute,&2=master solo. This is deprecated as you can just query the master track as well.
REAPERAPI_DECL int (*GetMasterMuteSoloFlags)();

// returns max dev for midi inputs/outputs
REAPERAPI_DECL int (*GetMaxMidiInputs)();

REAPERAPI_DECL int (*GetMaxMidiOutputs)();

// get an item from a project by item count (zero-based) (proj=0 for active project)
REAPERAPI_DECL MediaItem* (*GetMediaItem)(ReaProject* proj, int itemidx);

// Get parent track of media item
REAPERAPI_DECL MediaTrack* (*GetMediaItem_Track)(MediaItem* item);

// Get media item numerical-value attributes.
// B_MUTE : bool * to muted state
// B_LOOPSRC : bool * to loop source
// B_ALLTAKESPLAY : bool * to all takes play
// B_UISEL : bool * to ui selected
// C_BEATATTACHMODE : char * to one char of beat attached mode, -1=def, 0=time, 1=allbeats, 2=beatsosonly
// C_LOCK : char * to one char of lock flags (&1 is locked, currently)
// D_VOL : double * of item volume (volume bar)
// D_POSITION : double * of item position (seconds)
// D_LENGTH : double * of item length (seconds)
// D_SNAPOFFSET : double * of item snap offset (seconds)
// D_FADEINLEN : double * of item fade in length (manual, seconds)
// D_FADEOUTLEN : double * of item fade out length (manual, seconds)
// D_FADEINLEN_AUTO : double * of item autofade in length (seconds, -1 for no autofade set)
// D_FADEOUTLEN_AUTO : double * of item autofade out length (seconds, -1 for no autofade set)
// C_FADEINSHAPE : int * to fadein shape, 0=linear, ...
// C_FADEOUTSHAPE : int * to fadeout shape
// I_GROUPID : int * to group ID (0 = no group)
// I_LASTY : int * to last y position in track (readonly)
// I_LASTH : int * to last height in track (readonly)
// I_CUSTOMCOLOR : int * : custom color, windows standard color order (i.e. RGB(r,g,b)|0x100000). if you do not |0x100000, then it will not be used (though will store the color anyway)
// I_CURTAKE : int * to active take
// F_FREEMODE_Y : float * to free mode y position (0..1)
// F_FREEMODE_H : float * to free mode height (0..1)
REAPERAPI_DECL double (*GetMediaItemInfo_Value)(MediaItem* item, const char* parmname);

REAPERAPI_DECL int (*GetMediaItemNumTakes)(MediaItem* item);

REAPERAPI_DECL MediaItem_Take* (*GetMediaItemTake)(MediaItem* item, int tk);

// Get parent item of media item take
REAPERAPI_DECL MediaItem* (*GetMediaItemTake_Item)(MediaItem_Take* take);

// Get media source of media item take
REAPERAPI_DECL PCM_source* (*GetMediaItemTake_Source)(MediaItem_Take* take);

// Get parent track of media item take
REAPERAPI_DECL MediaTrack* (*GetMediaItemTake_Track)(MediaItem_Take* take);

// Get media item take numerical-value attributes.
// D_STARTOFFS : double *, start offset in take of item
// D_VOL : double *, take volume
// D_PAN : double *, take pan
// D_PANLAW : double *, take pan law (-1.0=default, 0.5=-6dB, 1.0=+0dB, etc)
// D_PLAYRATE : double *, take play rate (1.0=normal, 2.0=doublespeed, etc)
// D_PITCH : double *, take pitch adjust (in semitones, 0.0=normal, +12 = one octave up, etc)
// B_PPITCH, bool *, preserve pitch when changing rate
// I_CHANMODE, int *, channel mode (0=normal, 1=revstereo, 2=downmix, 3=l, 4=r)
// I_PITCHMODE, int *, pitch shifter mode, -1=proj default, otherwise high word=shifter low word = parameter
REAPERAPI_DECL double (*GetMediaItemTakeInfo_Value)(MediaItem_Take* take, const char* parmname);

// Get track numerical-value attributes.
// B_MUTE : bool * : mute flag
// B_PHASE : bool * : invert track phase
// IP_TRACKNUMBER : int : track number (returns zero if not found, -1 for master track) (read-only, returns the int directly)
// I_SOLO : int * : 0=not soloed, 1=solo, 2=soloed in place
// I_FXEN : int * : 0=fx bypassed, nonzero = fx active
// I_RECARM : int * : 0=not record armed, 1=record armed
// I_RECINPUT : int * : record input. 0..n = mono hardware input, 512+n = rearoute input, 1024 set for stereo input pair. 4096 set for MIDI input, if set, then low 5 bits represent channel (0=all, 1-16=only chan), then next 5 bits represent physical input (31=all, 30=VKB)
// I_RECMODE : int * : record mode (0=input, 1=stereo out, 2=none, 3=stereo out w/latcomp, 4=midi output, 5=mono out, 6=mono out w/ lat comp, 7=midi overdub, 8=midi replace
// I_RECMON : int * : record monitor (0=off, 1=normal, 2=not when playing (tapestyle))
// I_RECMONITEMS : int * : monitor items while recording (0=off, 1=on)
// I_AUTOMODE : int * : track automation mode (0=trim/off, 1=read, 2=touch, 3=write, 4=latch
// I_NCHAN : int * : number of track channels, must be 2-64, even
// I_SELECTED : int * : track selected? 0 or 1
// I_WNDH : int * : current TCP window height (Read-only)
// I_FOLDERDEPTH : int * : folder depth change (0=normal, 1=track is a folder parent, -1=track is the last in the innermost folder, -2=track is the last in the innermost and next-innermost folders, etc
// I_FOLDERCOMPACT : int * : folder compacting (only valid on folders), 0=normal, 1=small, 2=tiny children
// I_MIDIHWOUT : int * : track midi hardware output index (<0 for disabled, low 5 bits are which channels (0=all, 1-16), next 5 bits are output device index (0-31))
// I_PERFFLAGS : int * : track perf flags (&1=no media buffering, &2=no anticipative FX)
// I_CUSTOMCOLOR : int * : custom color, windows standard color order (i.e. RGB(r,g,b)|0x100000). if you do not |0x100000, then it will not be used (though will store the color anyway)
// I_HEIGHTOVERRIDE : int * : custom height override for TCP window. 0 for none, otherwise size in pixels
// D_VOL : double * : trim volume of track (0 (-inf)..1 (+0dB) .. 2 (+6dB) etc ..)
// D_PAN : double * : trim pan of track (-1..1)
// D_PANLAW : double * : pan law of track. <0 for project default, 1.0 for +0dB, etc
// B_SHOWINMIXER : bool * : show track panel in mixer -- do not use on master
// B_SHOWINTCP : bool * : show track panel in tcp -- do not use on master
// B_MAINSEND : bool * : track sends audio to parent
// B_FREEMODE : bool * : track free-mode enabled (requires UpdateTimeline() after changing etc)
// C_BEATATTACHMODE : char * : char * to one char of beat attached mode, -1=def, 0=time, 1=allbeats, 2=beatsposonly
// F_MCP_FXSEND_SCALE : float * : scale of fx+send area in MCP (0.0=smallest allowed, 1=max allowed)
// F_MCP_SENDRGN_SCALE : float * : scale of send area as proportion of the fx+send total area (0=min allow, 1=max)
REAPERAPI_DECL double (*GetMediaTrackInfo_Value)(MediaTrack* tr, const char* parmname);

REAPERAPI_DECL midi_Input* (*GetMidiInput)(int idx);

// returns true if device present
REAPERAPI_DECL bool (*GetMIDIInputName)(int dev, char* nameout, int nameoutlen);

REAPERAPI_DECL midi_Output* (*GetMidiOutput)(int idx);

// returns true if device present
REAPERAPI_DECL bool (*GetMIDIOutputName)(int dev, char* nameout, int nameoutlen);

// returns actual number of midi inputs (slower)
REAPERAPI_DECL int (*GetNumMIDIInputs)();

// returns actual number of midi outputs (slower)
REAPERAPI_DECL int (*GetNumMIDIOutputs)();

REAPERAPI_DECL int (*GetNumTracks)();

REAPERAPI_DECL const char* (*GetOutputChannelName)(int idx);

// returns output latency in seconds
REAPERAPI_DECL double (*GetOutputLatency)();

// get the peak file name for a given file (can be either filename.reapeaks,or a hashed filename in another path)
REAPERAPI_DECL void (*GetPeakFileName)(const char* fn, char* buf, int bufmax);

// see note in reaper_plugin.h about PCM_source_peaktransfer_t::samplerate
REAPERAPI_DECL void* (*GetPeaksBitmap)(PCM_source_peaktransfer_t* pks, double maxamp, int w, int h, LICE_IBitmap* bmp);

// returns latency-compensated actual-what-you-hear position
REAPERAPI_DECL double (*GetPlayPosition)();

// returns position of next audio block being processed
REAPERAPI_DECL double (*GetPlayPosition2)();

// returns position of next audio block being processed
REAPERAPI_DECL double (*GetPlayPosition2Ex)(void* proj);

// returns latency-compensated actual-what-you-hear position
REAPERAPI_DECL double (*GetPlayPositionEx)(void* proj);

// &1=playing,&2=pause,&=4 is recording
REAPERAPI_DECL int (*GetPlayState)();

// &1=playing,&2=pause,&=4 is recording
REAPERAPI_DECL int (*GetPlayStateEx)(void* proj);

REAPERAPI_DECL void (*GetProjectPath)(char* buf, int bufsz);

REAPERAPI_DECL void (*GetProjectPathEx)(void* proj, char* buf, int bufsz);

// deprecated
REAPERAPI_DECL void (*GetProjectTimeSignature)(double* bpm, double* bpi);

// Gets basic time signature (beats per minute, numerator of time signature in bpi)
// this does not reflect tempo envelopes but is purely what is set in the project settings.
REAPERAPI_DECL void (*GetProjectTimeSignature2)(ReaProject* proj, double* bpm, double* bpi);

// get a selected item by selected item count (zero-based) (proj=0 for active project)
REAPERAPI_DECL MediaItem* (*GetSelectedMediaItem)(ReaProject* proj, int selitem);

// get a selected track from a project by selected track count (zero-based) (proj=0 for active project)
REAPERAPI_DECL MediaTrack* (*GetSelectedTrack)(ReaProject* proj, int seltrackidx);

// get the currently selected track envelope, returns 0 if no envelope is selected
REAPERAPI_DECL TrackEnvelope* (*GetSelectedTrackEnvelope)(ReaProject* proj);

REAPERAPI_DECL void (*GetSet_ArrangeView2)(void* proj, bool isSet, int screen_x_start, int screen_x_end, double* start_time, double* end_time);

REAPERAPI_DECL void (*GetSet_LoopTimeRange)(bool isSet, bool isLoop, double* start, double* end, bool allowautoseek);

REAPERAPI_DECL void (*GetSet_LoopTimeRange2)(void* proj, bool isSet, bool isLoop, double* start, double* end, bool allowautoseek);

// get or set the state of an envelope as an xml/rpp chunk.
// supply str="" to get the state returned in str.
// the returned state string is limited to maxlen characters, though there is an upper limit (currently 16K) on maxlen.
// supply str as an xml/rpp string to set the object state.
// returns true on success.
REAPERAPI_DECL bool (*GetSetEnvelopeState)(TrackEnvelope* env, char* str, int maxlen);

// get or set the state of a media item as an xml/rpp chunk.
// supply str="" to get the state returned in str.
// the returned state string is limited to maxlen characters, though there is an upper limit (currently 16K) on maxlen.
// supply str as an xml/rpp string to set the object state.
// returns true on success.
REAPERAPI_DECL bool (*GetSetItemState)(MediaItem* item, char* str, int maxlen);

// P_TRACK : MediaTrack * (read only)
// B_MUTE : bool * to muted state
// B_LOOPSRC : bool * to loop source
// B_ALLTAKESPLAY : bool * to all takes play
// B_UISEL : bool * to ui selected
// C_BEATATTACHMODE : char * to one char of beat attached mode, -1=def, 0=time, 1=allbeats, 2=beatsosonly
// C_LOCK : char * to one char of lock flags (&1 is locked, currently)
// D_VOL : double * of item volume (volume bar)
// D_POSITION : double * of item position (seconds)
// D_LENGTH : double * of item length (seconds)
// D_SNAPOFFSET : double * of item snap offset (seconds)
// D_FADEINLEN : double * of item fade in length (manual, seconds)
// D_FADEOUTLEN : double * of item fade out length (manual, seconds)
// D_FADEINLEN_AUTO : double * of item autofade in length (seconds, -1 for no autofade set)
// D_FADEOUTLEN_AUTO : double * of item autofade out length (seconds, -1 for no autofade set)
// C_FADEINSHAPE : int * to fadein shape, 0=linear, ...
// C_FADEOUTSHAPE : int * to fadeout shape
// I_GROUPID : int * to group ID (0 = no group)
// I_LASTY : int * to last y position in track (readonly)
// I_LASTH : int * to last height in track (readonly)
// I_CUSTOMCOLOR : int * : custom color, windows standard color order (i.e. RGB(r,g,b)|0x100000). if you do not |0x100000, then it will not be used (though will store the color anyway)
// I_CURTAKE : int * to active take
// F_FREEMODE_Y : float * to free mode y position (0..1)
// F_FREEMODE_H : float * to free mode height (0..1)
REAPERAPI_DECL void* (*GetSetMediaItemInfo)(MediaItem* item, const char* parmname, void* setNewValue);

// P_TRACK : pointer to MediaTrack (read-only)
// P_ITEM : pointer to MediaItem (read-only)
// P_SOURCE : PCM_source *. Note that if setting this, you should first retrieve the old source, set the new, THEN delete the old.
// GUID : GUID * : 16-byte GUID, can query or update
// P_NAME : char * to take name
// D_STARTOFFS : double *, start offset in take of item
// D_VOL : double *, take volume
// D_PAN : double *, take pan
// D_PANLAW : double *, take pan law (-1.0=default, 0.5=-6dB, 1.0=+0dB, etc)
// D_PLAYRATE : double *, take play rate (1.0=normal, 2.0=doublespeed, etc)
// D_PITCH : double *, take pitch adjust (in semitones, 0.0=normal, +12 = one octave up, etc)
// B_PPITCH, bool *, preserve pitch when changing rate
// I_CHANMODE, int *, channel mode (0=normal, 1=revstereo, 2=downmix, 3=l, 4=r)
// I_PITCHMODE, int *, pitch shifter mode, -1=proj default, otherwise high word=shifter low word = parameter
REAPERAPI_DECL void* (*GetSetMediaItemTakeInfo)(MediaItem_Take* tk, const char* parmname, void* setNewValue);

// P_NAME : char * to take name
REAPERAPI_DECL bool (*GetSetMediaItemTakeInfo_String)(MediaItem_Take* tk, const char* parmname, char* string, bool setnewvalue);

// Get or set track attributes.
// P_PARTRACK : MediaTrack * : parent track (read-only)
// GUID : GUID * : 16-byte GUID, can query or update (do not use on master though)
// P_NAME : char * : track name (on master returns NULL)
// 
// B_MUTE : bool * : mute flag
// B_PHASE : bool * : invert track phase
// IP_TRACKNUMBER : int : track number (returns zero if not found, -1 for master track) (read-only, returns the int directly)
// I_SOLO : int * : 0=not soloed, 1=solo, 2=soloed in place
// I_FXEN : int * : 0=fx bypassed, nonzero = fx active
// I_RECARM : int * : 0=not record armed, 1=record armed
// I_RECINPUT : int * : record input. 0..n = mono hardware input, 512+n = rearoute input, 1024 set for stereo input pair. 4096 set for MIDI input, if set, then low 5 bits represent channel (0=all, 1-16=only chan), then next 5 bits represent physical input (31=all, 30=VKB)
// I_RECMODE : int * : record mode (0=input, 1=stereo out, 2=none, 3=stereo out w/latcomp, 4=midi output, 5=mono out, 6=mono out w/ lat comp, 7=midi overdub, 8=midi replace
// I_RECMON : int * : record monitor (0=off, 1=normal, 2=not when playing (tapestyle))
// I_RECMONITEMS : int * : monitor items while recording (0=off, 1=on)
// I_AUTOMODE : int * : track automation mode (0=trim/off, 1=read, 2=touch, 3=write, 4=latch
// I_NCHAN : int * : number of track channels, must be 2-64, even
// I_SELECTED : int * : track selected? 0 or 1
// I_WNDH : int * : current TCP window height (Read-only)
// I_FOLDERDEPTH : int * : folder depth change (0=normal, 1=track is a folder parent, -1=track is the last in the innermost folder, -2=track is the last in the innermost and next-innermost folders, etc
// I_FOLDERCOMPACT : int * : folder compacting (only valid on folders), 0=normal, 1=small, 2=tiny children
// I_MIDIHWOUT : int * : track midi hardware output index (<0 for disabled, low 5 bits are which channels (0=all, 1-16), next 5 bits are output device index (0-31))
// I_PERFFLAGS : int * : track perf flags (&1=no media buffering, &2=no anticipative FX)
// I_CUSTOMCOLOR : int * : custom color, windows standard color order (i.e. RGB(r,g,b)|0x100000). if you do not |0x100000, then it will not be used (though will store the color anyway)
// I_HEIGHTOVERRIDE : int * : custom height override for TCP window. 0 for none, otherwise size in pixels
// D_VOL : double * : trim volume of track (0 (-inf)..1 (+0dB) .. 2 (+6dB) etc ..)
// D_PAN : double * : trim pan of track (-1..1)
// D_PANLAW : double * : pan law of track. <0 for project default, 1.0 for +0dB, etc
// B_SHOWINMIXER : bool * : show track panel in mixer -- do not use on master
// B_SHOWINTCP : bool * : show track panel in tcp -- do not use on master
// B_MAINSEND : bool * : track sends audio to parent
// B_FREEMODE : bool * : track free-mode enabled (requires UpdateTimeline() after changing etc)
// C_BEATATTACHMODE : char * : char * to one char of beat attached mode, -1=def, 0=time, 1=allbeats, 2=beatsposonly
// F_MCP_FXSEND_SCALE : float * : scale of fx+send area in MCP (0.0=smallest allowed, 1=max allowed)
// F_MCP_SENDRGN_SCALE : float * : scale of send area as proportion of the fx+send total area (0=min allow, 1=max)
REAPERAPI_DECL void* (*GetSetMediaTrackInfo)(MediaTrack* tr, const char* parmname, void* setNewValue);

// Get or set track string attributes.
// P_NAME : char * : track name (on master returns NULL)
// 
REAPERAPI_DECL bool (*GetSetMediaTrackInfo_String)(MediaTrack* tr, const char* parmname, char* string, bool setnewvalue);

// get or set the state of a {track,item,envelope} as an xml/rpp chunk
// str="" to get the chunk string returned (must call FreeHeapPtr when done)
// supply str to set the state (returns zero)
REAPERAPI_DECL char* (*GetSetObjectState)(void* obj, const char* str);

// -1 == query,0=clear,1=set,>1=toggle . returns new value
REAPERAPI_DECL int (*GetSetRepeat)(int val);

// -1 == query,0=clear,1=set,>1=toggle . returns new value
REAPERAPI_DECL int (*GetSetRepeatEx)(void* proj, int val);

// category is <0 for receives, 0=sends, >0 for hardware outputs
// sendidx is 0..n (NULL on any required parameter to stop)
// parameter names:
// P_DESTTRACK : read only, returns MediaTrack *, destination track, only applies for sends/recvs
// P_SRCTRACK : read only, returns MediaTrack *, source track, only applies for sends/recvs
// B_MUTE : returns bool *, read/write
// B_PHASE : returns bool *, read/write, true to flip phase
// B_MONO : returns bool *, read/write
// D_VOL : returns double *, read/write, 1.0 = +0dB etc
// D_PAN : returns double *, read/write, -1..+1
// D_PANLAW : returns double *,read/write, 1.0=+0.0db, 0.5=-6dB, -1.0 = projdef etc
// I_SENDMODE : returns int *, read/write, 0=post-fader, 1=pre-fx, 2=post-fx(depr), 3=post-fx
// I_SRCCHAN : returns int *, read/write, index,&1024=mono, -1 for none
// I_DSTCHAN : returns int *, read/write, index, &1024=mono, otherwise stereo pair, hwout:&512=rearoute
// I_MIDIFLAGS : returns int *, read/write, low 5 bits=source channel 0=all, 1-16, next 5 bits=dest channel, 0=orig, 1-16=chan
REAPERAPI_DECL void* (*GetSetTrackSendInfo)(MediaTrack* tr, int category, int sendidx, const char* parmname, void* setNewValue);

// get or set the state of a track as an xml/rpp chunk.
// supply str="" to get the state returned in str.
// the returned state string is limited to maxlen characters, though there is an upper limit (currently 16K) on maxlen.
// supply str as an xml/rpp string to set the object state.
// returns true on success.
REAPERAPI_DECL bool (*GetSetTrackState)(MediaTrack* track, char* str, int maxlen);

// get a take from an item by take count (zero-based)
REAPERAPI_DECL MediaItem_Take* (*GetTake)(MediaItem* item, int takeidx);

REAPERAPI_DECL TrackEnvelope* (*GetTakeEnvelopeByName)(MediaItem_Take* take, const char* envmame);

// gets a tooltip window,in case you want to ask it for font information. Can return NULL.
REAPERAPI_DECL HWND (*GetTooltipWindow)();

// get a track from a project by track count (zero-based) (proj=0 for active project)
REAPERAPI_DECL MediaTrack* (*GetTrack)(ReaProject* proj, int trackidx);

REAPERAPI_DECL int (*GetTrackAutomationMode)(MediaTrack* tr);

REAPERAPI_DECL TrackEnvelope* (*GetTrackEnvelope)(MediaTrack* track, int envidx);

REAPERAPI_DECL TrackEnvelope* (*GetTrackEnvelopeByName)(MediaTrack* track, const char* envname);

REAPERAPI_DECL GUID* (*GetTrackGUID)(MediaTrack* tr);

// gets track info (returns name).
// track index, -1=master, 0..n, or cast a MediaTrack* to int
// if flags is non-NULL, will be set to:
// &1=folder
// &2=selected
// &4=has fx enabled
// &8=muted
// &16=soloed
// &32=SIP'd (with &16)
// &64=rec armed
REAPERAPI_DECL const char* (*GetTrackInfo)(INT_PTR track, int* flags);

REAPERAPI_DECL MediaItem* (*GetTrackMediaItem)(MediaTrack* tr, int itemidx);

REAPERAPI_DECL const char* (*GetTrackMIDINoteName)(int track, int note, int chan);

REAPERAPI_DECL const char* (*GetTrackMIDINoteNameEx)(void* proj, void* track, int note, int chan);

REAPERAPI_DECL int (*GetTrackNumMediaItems)(MediaTrack* tr);

// Gets track state, returns track name.
// flags will be set to:
// &1=folder
// &2=selected
// &4=has fx enabled
// &8=muted
// &16=soloed
// &32=SIP'd (with &16)
// &64=rec armed
REAPERAPI_DECL const char* (*GetTrackState)(MediaTrack* track, int* flags);

REAPERAPI_DECL bool (*GetTrackUIVolPan)(MediaTrack* tr, double* vol, double* pan);

// Get values from the user.
// Values are returned as a comma-separated string. Returns false if the user canceled the dialog.
REAPERAPI_DECL bool (*GetUserInputs)(const char* title, int num_inputs, const char* captions_csv, char* retvals_csv, int max_retval_len);

// this is just like win32 GetSysColor() but can have overrides.
REAPERAPI_DECL int (*GSC_mainwnd)(int t);

// dest should be at least 64 chars long to be safe
REAPERAPI_DECL void (*guidToString)(GUID* g, char* dest);

// returns name of track plugin that is supplying MIDI programs,or NULL if there is none
REAPERAPI_DECL const char* (*HasTrackMIDIPrograms)(int track);

// returns name of track plugin that is supplying MIDI programs,or NULL if there is none
REAPERAPI_DECL const char* (*HasTrackMIDIProgramsEx)(void* proj, void* track);

REAPERAPI_DECL void (*HiresPeaksFromSource)(PCM_source* src, PCM_source_peaktransfer_t* block);

REAPERAPI_DECL int (*InsertMedia)(char* file, int mode);

// inserts a track at idx,of course this will be clamped to 0..GetNumTracks(). wantDefaults=TRUE for default envelopes/FX,otherwise no enabled fx/env
REAPERAPI_DECL void (*InsertTrackAtIndex)(int idx, bool wantDefaults);

// are we in a realtime audio thread (between OnAudioBuffer calls,not in some worker/anticipative FX thread)? threadsafe
REAPERAPI_DECL int (*IsInRealTimeAudio)();

REAPERAPI_DECL bool (*IsMediaExtension)(const char* ext, bool wantOthers);

REAPERAPI_DECL int (*kbd_enumerateActions)(KbdSectionInfo* section, int idx, const char** nameOut);

REAPERAPI_DECL void (*kbd_formatKeyName)(ACCEL* ac, char* s);

REAPERAPI_DECL void (*kbd_getCommandName)(int cmd, char* s, KbdSectionInfo* section);

REAPERAPI_DECL const char* (*kbd_getTextFromCmd)(DWORD cmd, KbdSectionInfo* section);

// val/valhw are used for midi stuff.
// val=[0..127] and valhw=-1 (midi CC),
// valhw >=0 (midi pitch (valhw | val<<7)),
// relmode absolute (0) or 1/2/3 for relative adjust modes
REAPERAPI_DECL int (*KBD_OnMainActionEx)(int cmd, int val, int valhw, int relmode, HWND hwnd, ReaProject* proj);

// can be called from anywhere (threadsafe)
REAPERAPI_DECL void (*kbd_OnMidiEvent)(MIDI_event_t* evt, int dev_index);

// can be called from anywhere (threadsafe)
REAPERAPI_DECL void (*kbd_OnMidiList)(MIDI_eventlist* list, int dev_index);

REAPERAPI_DECL void (*kbd_ProcessActionsMenu)(HMENU menu, KbdSectionInfo* section);

REAPERAPI_DECL bool (*kbd_processMidiEventActionEx)(MIDI_event_t* evt, KbdSectionInfo* section, HWND hwndCtx);

REAPERAPI_DECL void (*kbd_reprocessMenu)(HMENU menu, KbdSectionInfo* section);

// actioncommandID may get modified
REAPERAPI_DECL bool (*kbd_RunCommandThroughHooks)(KbdSectionInfo* section, int* actionCommandID, int* val, int* valhw, int* relmode, HWND hwnd);

// time formatting mode overrides: -1=proj default.
// 0=time
// 1=measures:beats + time
// 2=measures:beats
// 3=seconds
// 4=samples
// 5=h:m:s:f
REAPERAPI_DECL int (*kbd_translateAccelerator)(HWND hwnd, MSG* msg, KbdSectionInfo* section);

#ifndef _LICE_H

REAPERAPI_DECL void (*LICE__Destroy)(LICE_IBitmap* bm);

REAPERAPI_DECL void (*LICE__DestroyFont)(LICE_IFont* font);

REAPERAPI_DECL int (*LICE__DrawText)(LICE_IFont* font, LICE_IBitmap* bm, const char* str, int strcnt, RECT* rect, UINT dtFlags);

REAPERAPI_DECL void* (*LICE__GetBits)(LICE_IBitmap* bm);

REAPERAPI_DECL HDC (*LICE__GetDC)(LICE_IBitmap* bm);

REAPERAPI_DECL int (*LICE__GetHeight)(LICE_IBitmap* bm);

REAPERAPI_DECL int (*LICE__GetRowSpan)(LICE_IBitmap* bm);

REAPERAPI_DECL int (*LICE__GetWidth)(LICE_IBitmap* bm);

REAPERAPI_DECL bool (*LICE__IsFlipped)(LICE_IBitmap* bm);

REAPERAPI_DECL bool (*LICE__resize)(LICE_IBitmap* bm, int w, int h);

REAPERAPI_DECL LICE_pixel (*LICE__SetBkColor)(LICE_IFont* font, LICE_pixel color);

// font must REMAIN valid,unless LICE_FONT_FLAG_PRECALCALL is set
REAPERAPI_DECL void (*LICE__SetFromHFont)(LICE_IFont* font, HFONT hfont, int flags);

REAPERAPI_DECL LICE_pixel (*LICE__SetTextColor)(LICE_IFont* font, LICE_pixel color);

REAPERAPI_DECL void (*LICE__SetTextCombineMode)(LICE_IFont* ifont, int mode, float alpha);

REAPERAPI_DECL void (*LICE_Arc)(LICE_IBitmap* dest, float cx, float cy, float r, float minAngle, float maxAngle, LICE_pixel color, float alpha, int mode, bool aa);

REAPERAPI_DECL void (*LICE_Blit)(LICE_IBitmap* dest, LICE_IBitmap* src, int dstx, int dsty, int srcx, int srcy, int srcw, int srch, float alpha, int mode);

REAPERAPI_DECL void (*LICE_Blur)(LICE_IBitmap* dest, LICE_IBitmap* src, int dstx, int dsty, int srcx, int srcy, int srcw, int srch);

REAPERAPI_DECL void (*LICE_BorderedRect)(LICE_IBitmap* dest, int x, int y, int w, int h, LICE_pixel bgcolor, LICE_pixel fgcolor, float alpha, int mode);

REAPERAPI_DECL void (*LICE_Circle)(LICE_IBitmap* dest, float cx, float cy, float r, LICE_pixel color, float alpha, int mode, bool aa);

REAPERAPI_DECL void (*LICE_Clear)(LICE_IBitmap* dest, LICE_pixel color);

REAPERAPI_DECL void (*LICE_ClearRect)(LICE_IBitmap* dest, int x, int y, int w, int h, LICE_pixel mask, LICE_pixel orbits);

// Returns false if the line is entirely offscreen.
REAPERAPI_DECL bool (*LICE_ClipLine)(int* pX1, int* pY1, int* pX2, int* pY2, int xLo, int yLo, int xHi, int yHi);

// create a new bitmap. this is like calling new LICE_MemBitmap (mode=0) or new LICE_SysBitmap (mode=1).
REAPERAPI_DECL LICE_IBitmap* (*LICE_CreateBitmap)(int mode, int w, int h);

REAPERAPI_DECL LICE_IFont* (*LICE_CreateFont)();

REAPERAPI_DECL void (*LICE_DrawChar)(LICE_IBitmap* bm, int x, int y, char c, LICE_pixel color, float alpha, int mode);

REAPERAPI_DECL void (*LICE_DrawGlyph)(LICE_IBitmap* dest, int x, int y, LICE_pixel color, LICE_pixel_chan* alphas, int glyph_w, int glyph_h, float alpha, int mode);

REAPERAPI_DECL void (*LICE_DrawRect)(LICE_IBitmap* dest, int x, int y, int w, int h, LICE_pixel color, float alpha, int mode);

REAPERAPI_DECL void (*LICE_DrawText)(LICE_IBitmap* bm, int x, int y, const char* string, LICE_pixel color, float alpha, int mode);

REAPERAPI_DECL void (*LICE_FillCircle)(LICE_IBitmap* dest, float cx, float cy, float r, LICE_pixel color, float alpha, int mode, bool aa);

REAPERAPI_DECL void (*LICE_FillRect)(LICE_IBitmap* dest, int x, int y, int w, int h, LICE_pixel color, float alpha, int mode);

REAPERAPI_DECL void (*LICE_FillTriangle)(LICE_IBitmap* dest, int x1, int y1, int x2, int y2, int x3, int y3, LICE_pixel color, float alpha, int mode);

REAPERAPI_DECL LICE_pixel (*LICE_GetPixel)(LICE_IBitmap* bm, int x, int y);

REAPERAPI_DECL void (*LICE_GradRect)(LICE_IBitmap* dest, int dstx, int dsty, int dstw, int dsth, float ir, float ig, float ib, float ia, float drdx, float dgdx, float dbdx, float dadx, float drdy, float dgdy, float dbdy, float dady, int mode);

REAPERAPI_DECL void (*LICE_Line)(LICE_IBitmap* dest, int x1, int y1, int x2, int y2, LICE_pixel color, float alpha, int mode, bool aa);

REAPERAPI_DECL void (*LICE_LineInt)(LICE_IBitmap* dest, int x1, int y1, int x2, int y2, LICE_pixel color, float alpha, int mode, bool aa);

REAPERAPI_DECL LICE_IBitmap* (*LICE_LoadPNG)(const char* filename, LICE_IBitmap* bmp);

REAPERAPI_DECL LICE_IBitmap* (*LICE_LoadPNGFromResource)(HINSTANCE hInst, int resid, LICE_IBitmap* bmp);

REAPERAPI_DECL void (*LICE_MeasureText)(const char* string, int* w, int* h);

REAPERAPI_DECL void (*LICE_MultiplyAddRect)(LICE_IBitmap* dest, int x, int y, int w, int h, float rsc, float gsc, float bsc, float asc, float radd, float gadd, float badd, float aadd);

REAPERAPI_DECL void (*LICE_PutPixel)(LICE_IBitmap* bm, int x, int y, LICE_pixel color, float alpha, int mode);

// these coordinates are offset from the center of the image,in source pixel coordinates
REAPERAPI_DECL void (*LICE_RotatedBlit)(LICE_IBitmap* dest, LICE_IBitmap* src, int dstx, int dsty, int dstw, int dsth, float srcx, float srcy, float srcw, float srch, float angle, bool cliptosourcerect, float alpha, int mode, float rotxcent, float rotycent);

REAPERAPI_DECL void (*LICE_RoundRect)(LICE_IBitmap* drawbm, float xpos, float ypos, float w, float h, int cornerradius, LICE_pixel col, float alpha, int mode, bool aa);

REAPERAPI_DECL void (*LICE_ScaledBlit)(LICE_IBitmap* dest, LICE_IBitmap* src, int dstx, int dsty, int dstw, int dsth, float srcx, float srcy, float srcw, float srch, float alpha, int mode);

REAPERAPI_DECL void (*LICE_SimpleFill)(LICE_IBitmap* dest, int x, int y, LICE_pixel newcolor, LICE_pixel comparemask, LICE_pixel keepmask);

#endif // _LICE_H

REAPERAPI_DECL void (*Main_OnCommand)(int command, int flag);

REAPERAPI_DECL void (*Main_OnCommandEx)(int command, int flag, void* proj);

// opens a project. will prompt the user to save, etc.
// if you pass a .RTrackTemplate file then it adds that to the project instead.
REAPERAPI_DECL void (*Main_openProject)(char* name);

REAPERAPI_DECL void (*Main_UpdateLoopInfo)(int ignoremask);

REAPERAPI_DECL double (*Master_GetPlayRateAtTime)(double time_s, ReaProject* proj);

// type 0=OK,2=OKCANCEL,2=ABORTRETRYIGNORE,3=YESNOCANCEL,4=YESNO,5=RETRYCANCEL : ret 1=OK,2=CANCEL,3=ABORT,4=RETRY,5=IGNORE,6=YES,7=NO
REAPERAPI_DECL int (*MB)(const char* msg, const char* title, int type);

// Create a MIDI_eventlist object. The returned object must be deleted with MIDI_eventlist_destroy().
REAPERAPI_DECL MIDI_eventlist* (*MIDI_eventlist_Create)();

// Destroy a MIDI_eventlist object that was created using MIDI_eventlist_Create().
REAPERAPI_DECL void (*MIDI_eventlist_Destroy)(MIDI_eventlist* evtlist);

// get a pointer to the focused MIDI editor window
// see MIDIEditor_GetMode, MIDIEditor_OnCommand
REAPERAPI_DECL void* (*MIDIEditor_GetActive)();

// get the mode of a MIDI editor (0=piano roll, 1=event list, -1=invalid editor)
// see MIDIEditor_GetActive, MIDIEditor_OnCommand
REAPERAPI_DECL int (*MIDIEditor_GetMode)(void* midieditor);

// Send an action command to a MIDI editor. Returns false if the supplied MIDI editor pointer is not valid (not an open MIDI editor).
// see MIDIEditor_GetActive, MIDIEditor_OnCommand
REAPERAPI_DECL bool (*MIDIEditor_OnCommand)(void* midieditor, int command_id);

REAPERAPI_DECL void (*mkpanstr)(char* str, double pan);

REAPERAPI_DECL void (*mkvolpanstr)(char* str, double vol, double pan);

REAPERAPI_DECL void (*mkvolstr)(char* str, double vol);

REAPERAPI_DECL void (*MoveEditCursor)(double adjamt, bool dosel);

// returns TRUE if move succeeded
REAPERAPI_DECL bool (*MoveMediaItemToTrack)(MediaItem* item, MediaTrack* desttr);

REAPERAPI_DECL void (*MuteAllTracks)(bool mute);

REAPERAPI_DECL void (*my_getViewport)(RECT* r, RECT* sr, bool wantWort);

// get the command ID number for named command that was registered by an extension (such as "_SWS_ABOUT", etc)
REAPERAPI_DECL int (*NamedCommandLookup)(const char* command_name);

// direct way to simulate pause button hit
REAPERAPI_DECL void (*OnPauseButton)();

// direct way to simulate pause button hit
REAPERAPI_DECL void (*OnPauseButtonEx)(void* proj);

// direct way to simulate play button hit
REAPERAPI_DECL void (*OnPlayButton)();

// direct way to simulate play button hit
REAPERAPI_DECL void (*OnPlayButtonEx)(void* proj);

// direct way to simulate stop button hit
REAPERAPI_DECL void (*OnStopButton)();

// direct way to simulate stop button hit
REAPERAPI_DECL void (*OnStopButtonEx)(void* proj);

// time formatting mode overrides: -1=proj default.
// 0=time
// 1=measures:beats + time
// 2=measures:beats
// 3=seconds
// 4=samples
// 5=h:m:s:f
REAPERAPI_DECL double (*parse_timestr)(const char* buf);

// time formatting mode overrides: -1=proj default.
// 0=time
// 1=measures:beats + time
// 2=measures:beats
// 3=seconds
// 4=samples
// 5=h:m:s:f
REAPERAPI_DECL double (*parse_timestr_len)(const char* buf, double offset, int modeoverride);

// parses time string,modeoverride see above
REAPERAPI_DECL double (*parse_timestr_pos)(const char* buf, int modeoverride);

REAPERAPI_DECL double (*parsepanstr)(char* str);

REAPERAPI_DECL PCM_sink* (*PCM_Sink_Create)(const char* filename, const char* cfg, int cfgl, int nch, int srate, bool buildpeaks);

REAPERAPI_DECL PCM_sink* (*PCM_Sink_CreateEx)(void* proj, const char* filename, const char* cfg, int cfgl, int nch, int srate, bool buildpeaks);

REAPERAPI_DECL PCM_sink* (*PCM_Sink_CreateMIDIFile)(const char* filename, const char* cfg, int cfgl, double bpm, int div);

REAPERAPI_DECL PCM_sink* (*PCM_Sink_CreateMIDIFileEx)(void* proj, const char* filename, const char* cfg, int cfgl, double bpm, int div);

REAPERAPI_DECL unsigned int (*PCM_Sink_Enum)(int id, char** descstr);

REAPERAPI_DECL const char* (*PCM_Sink_GetExtension)(const void* data, int data_size);

REAPERAPI_DECL HWND (*PCM_Sink_ShowConfig)(const void* cfg, int cfg_l, HWND hwndParent);

REAPERAPI_DECL PCM_source* (*PCM_Source_CreateFromFile)(const char* filename);

REAPERAPI_DECL PCM_source* (*PCM_Source_CreateFromFileEx)(const char* filename, bool forcenoMidiImp);

// Creates a PCM_source from a ISimpleMediaDecoder
// (if fn is non-null, it will open the file in dec)
REAPERAPI_DECL PCM_source* (*PCM_Source_CreateFromSimple)(ISimpleMediaDecoder* dec, const char* fn);

REAPERAPI_DECL PCM_source* (*PCM_Source_CreateFromType)(const char* sourcetype);

REAPERAPI_DECL REAPER_PeakBuild_Interface* (*PeakBuild_Create)(PCM_source* src, const char* fn, int srate, int nch);

REAPERAPI_DECL REAPER_PeakGet_Interface* (*PeakGet_Create)(const char* fn, int srate, int nch);

// return nonzero on success
REAPERAPI_DECL int (*PlayPreview)(preview_register_t* preview);

// return nonzero on success,in these,m_out_chan is a track index (0-n)
REAPERAPI_DECL int (*PlayTrackPreview)(preview_register_t* preview);

// return nonzero on success,in these,m_out_chan is a track index (0-n)
REAPERAPI_DECL int (*PlayTrackPreview2)(void* proj, preview_register_t* preview);

REAPERAPI_DECL void* (*plugin_getapi)(const char* name);

REAPERAPI_DECL char* (*plugin_getFilterList)();

REAPERAPI_DECL char* (*plugin_getImportableProjectFilterList)();

// like rec->Register
// 
// register("myAPIfunc",funcaddress) then other plug-ins can use GetFunc("myAPIfunc")
// (use "-myAPIfunc" to unregister)
// another thing you can register is "hookcommand", which you pass a function:
//  NON_API: bool runCommand(int command, int flag);
//           register("hookcommand",runCommand);nwhich returns TRUE to eat (process) the command. flag is usually 0 but can sometimes have useful info depending on the message
// note: it's OK to call Main_OnCommand() within your runCommand, however you MUST check for recursion if doing so!
// in fact, any use of this hook should benefit from a simple reentrancy test...
// 
// you can also register command IDs for main window actions,
// register with "command_id", parameter is a unique string with only A-Z, 0-9,
// returns command ID for main actions (or 0 if not supported/out of actions)
// 
// register("command_id_lookup", unique_string) will look up the integer ID of the named action
// without registering the string if it doesn't already exist.
REAPERAPI_DECL int (*plugin_register)(const char* name, void* infostruct);

REAPERAPI_DECL void (*PluginWantsAlwaysRunFx)(int amt);

REAPERAPI_DECL void* (*projectconfig_var_addr)(ReaProject* proj, int idx);

// makes filename relative to the current project, if any
REAPERAPI_DECL int (*projectconfig_var_getoffs)(const char* name, int* szout);

// version must be REAPER_PITCHSHIFT_API_VER
REAPERAPI_DECL IReaperPitchShift* (*ReaperGetPitchShiftAPI)(int version);

REAPERAPI_DECL void (*relative_fn)(const char* in, char* out, int outlen);

REAPERAPI_DECL const char* (*Resample_EnumModes)(int mode);

REAPERAPI_DECL REAPER_Resample_Interface* (*Resampler_Create)();

REAPERAPI_DECL void (*resolve_fn)(const char* in, char* out, int outlen);

REAPERAPI_DECL void (*screenset_register)(char* id, screensetCallbackFunc callbackFunc, void* param);

REAPERAPI_DECL void (*screenset_unregister)(char* id);

REAPERAPI_DECL void (*screenset_unregisterByParam)(void* param);

REAPERAPI_DECL void (*SelectProjectInstance)(ReaProject* proj);

// sets all or selected tracks to mode.
REAPERAPI_DECL void (*SetAutomationMode)(int mode, bool onlySel);

REAPERAPI_DECL void (*SetEditCurPos)(double time, bool moveview, bool seekplay);

REAPERAPI_DECL void (*SetEditCurPos2)(void* proj, double time, bool moveview, bool seekplay);

// Set media item numerical-value attributes.
// B_MUTE : bool * to muted state
// B_LOOPSRC : bool * to loop source
// B_ALLTAKESPLAY : bool * to all takes play
// B_UISEL : bool * to ui selected
// C_BEATATTACHMODE : char * to one char of beat attached mode, -1=def, 0=time, 1=allbeats, 2=beatsosonly
// C_LOCK : char * to one char of lock flags (&1 is locked, currently)
// D_VOL : double * of item volume (volume bar)
// D_POSITION : double * of item position (seconds)
// D_LENGTH : double * of item length (seconds)
// D_SNAPOFFSET : double * of item snap offset (seconds)
// D_FADEINLEN : double * of item fade in length (manual, seconds)
// D_FADEOUTLEN : double * of item fade out length (manual, seconds)
// D_FADEINLEN_AUTO : double * of item autofade in length (seconds, -1 for no autofade set)
// D_FADEOUTLEN_AUTO : double * of item autofade out length (seconds, -1 for no autofade set)
// C_FADEINSHAPE : int * to fadein shape, 0=linear, ...
// C_FADEOUTSHAPE : int * to fadeout shape
// I_GROUPID : int * to group ID (0 = no group)
// I_LASTY : int * to last y position in track (readonly)
// I_LASTH : int * to last height in track (readonly)
// I_CUSTOMCOLOR : int * : custom color, windows standard color order (i.e. RGB(r,g,b)|0x100000). if you do not |0x100000, then it will not be used (though will store the color anyway)
// I_CURTAKE : int * to active take
// F_FREEMODE_Y : float * to free mode y position (0..1)
// F_FREEMODE_H : float * to free mode height (0..1)
REAPERAPI_DECL bool (*SetMediaItemInfo_Value)(MediaItem* item, const char* parmname, double newvalue);

// Set media item take numerical-value attributes.
// D_STARTOFFS : double *, start offset in take of item
// D_VOL : double *, take volume
// D_PAN : double *, take pan
// D_PANLAW : double *, take pan law (-1.0=default, 0.5=-6dB, 1.0=+0dB, etc)
// D_PLAYRATE : double *, take play rate (1.0=normal, 2.0=doublespeed, etc)
// D_PITCH : double *, take pitch adjust (in semitones, 0.0=normal, +12 = one octave up, etc)
// B_PPITCH, bool *, preserve pitch when changing rate
// I_CHANMODE, int *, channel mode (0=normal, 1=revstereo, 2=downmix, 3=l, 4=r)
// I_PITCHMODE, int *, pitch shifter mode, -1=proj default, otherwise high word=shifter low word = parameter
REAPERAPI_DECL bool (*SetMediaItemTakeInfo_Value)(MediaItem_Take* take, const char* parmname, double newvalue);

// Set track numerical-value attributes.
// B_MUTE : bool * : mute flag
// B_PHASE : bool * : invert track phase
// IP_TRACKNUMBER : int : track number (returns zero if not found, -1 for master track) (read-only, returns the int directly)
// I_SOLO : int * : 0=not soloed, 1=solo, 2=soloed in place
// I_FXEN : int * : 0=fx bypassed, nonzero = fx active
// I_RECARM : int * : 0=not record armed, 1=record armed
// I_RECINPUT : int * : record input. 0..n = mono hardware input, 512+n = rearoute input, 1024 set for stereo input pair. 4096 set for MIDI input, if set, then low 5 bits represent channel (0=all, 1-16=only chan), then next 5 bits represent physical input (31=all, 30=VKB)
// I_RECMODE : int * : record mode (0=input, 1=stereo out, 2=none, 3=stereo out w/latcomp, 4=midi output, 5=mono out, 6=mono out w/ lat comp, 7=midi overdub, 8=midi replace
// I_RECMON : int * : record monitor (0=off, 1=normal, 2=not when playing (tapestyle))
// I_RECMONITEMS : int * : monitor items while recording (0=off, 1=on)
// I_AUTOMODE : int * : track automation mode (0=trim/off, 1=read, 2=touch, 3=write, 4=latch
// I_NCHAN : int * : number of track channels, must be 2-64, even
// I_SELECTED : int * : track selected? 0 or 1
// I_WNDH : int * : current TCP window height (Read-only)
// I_FOLDERDEPTH : int * : folder depth change (0=normal, 1=track is a folder parent, -1=track is the last in the innermost folder, -2=track is the last in the innermost and next-innermost folders, etc
// I_FOLDERCOMPACT : int * : folder compacting (only valid on folders), 0=normal, 1=small, 2=tiny children
// I_MIDIHWOUT : int * : track midi hardware output index (<0 for disabled, low 5 bits are which channels (0=all, 1-16), next 5 bits are output device index (0-31))
// I_PERFFLAGS : int * : track perf flags (&1=no media buffering, &2=no anticipative FX)
// I_CUSTOMCOLOR : int * : custom color, windows standard color order (i.e. RGB(r,g,b)|0x100000). if you do not |0x100000, then it will not be used (though will store the color anyway)
// I_HEIGHTOVERRIDE : int * : custom height override for TCP window. 0 for none, otherwise size in pixels
// D_VOL : double * : trim volume of track (0 (-inf)..1 (+0dB) .. 2 (+6dB) etc ..)
// D_PAN : double * : trim pan of track (-1..1)
// D_PANLAW : double * : pan law of track. <0 for project default, 1.0 for +0dB, etc
// B_SHOWINMIXER : bool * : show track panel in mixer -- do not use on master
// B_SHOWINTCP : bool * : show track panel in tcp -- do not use on master
// B_MAINSEND : bool * : track sends audio to parent
// B_FREEMODE : bool * : track free-mode enabled (requires UpdateTimeline() after changing etc)
// C_BEATATTACHMODE : char * : char * to one char of beat attached mode, -1=def, 0=time, 1=allbeats, 2=beatsposonly
// F_MCP_FXSEND_SCALE : float * : scale of fx+send area in MCP (0.0=smallest allowed, 1=max allowed)
// F_MCP_SENDRGN_SCALE : float * : scale of send area as proportion of the fx+send total area (0=min allow, 1=max)
REAPERAPI_DECL bool (*SetMediaTrackInfo_Value)(MediaTrack* tr, const char* parmname, double newvalue);

REAPERAPI_DECL bool (*SetProjectMarker)(int markrgnindexnumber, bool isrgn, double pos, double rgnend, const char* name);

REAPERAPI_DECL bool (*SetProjectMarker2)(void* proj, int markrgnindexnumber, bool isrgn, double pos, double rgnend, const char* name);

REAPERAPI_DECL void (*SetTrackAutomationMode)(MediaTrack* tr, int mode);

REAPERAPI_DECL const char* (*SetTrackMIDINoteName)(int track, int note, int chan, const char* name);

REAPERAPI_DECL const char* (*SetTrackMIDINoteNameEx)(void* proj, void* track, int note, int chan, const char* name);

REAPERAPI_DECL void (*SetTrackSelected)(MediaTrack* tr, bool sel);

REAPERAPI_DECL void (*ShowActionList)(KbdSectionInfo* caller, HWND callerWnd);

// Show a message to the user (also useful for debugging). Send "\n" for newline, "" to clear the console window.
REAPERAPI_DECL void (*ShowConsoleMsg)(const char* msg);

// type 0=OK,2=OKCANCEL,2=ABORTRETRYIGNORE,3=YESNOCANCEL,4=YESNO,5=RETRYCANCEL : ret 1=OK,2=CANCEL,3=ABORT,4=RETRY,5=IGNORE,6=YES,7=NO
REAPERAPI_DECL int (*ShowMessageBox)(const char* msg, const char* title, int type);

REAPERAPI_DECL double (*SLIDER2DB)(double y);

// solo=2 for SIP
REAPERAPI_DECL void (*SoloAllTracks)(int solo);

// the original item becomes the left-hand split, the function returns the right-hand split (or NULL if the split failed)
REAPERAPI_DECL MediaItem* (*SplitMediaItem)(MediaItem* item, double position);

// return nonzero on success
REAPERAPI_DECL int (*StopPreview)(preview_register_t* preview);

// return nonzero on success
REAPERAPI_DECL int (*StopTrackPreview)(preview_register_t* preview);

// return nonzero on success
REAPERAPI_DECL int (*StopTrackPreview2)(void* proj, preview_register_t* preview);

REAPERAPI_DECL void (*stringToGuid)(const char* str, GUID* g);

// convert a beat position (or optionally a beats+measures if measures is non-NULL) to time.
REAPERAPI_DECL double (*TimeMap2_beatsToTime)(ReaProject* proj, double tpos, int* measures);

// get the effective BPM at the time (seconds) position (i.e. 2x in /8 signatures)
REAPERAPI_DECL double (*TimeMap2_GetDividedBpmAtTime)(ReaProject* proj, double time);

// when does the next time map (tempo or time sig) change occur
REAPERAPI_DECL double (*TimeMap2_GetNextChangeTime)(ReaProject* proj, double time);

// converts project QN position to time.
REAPERAPI_DECL double (*TimeMap2_QNToTime)(ReaProject* proj, double qn);

// convert a time into beats.
// if measures is non-NULL, measures will be set to the measure count, return value will be beats since measure.
// if cml is non-NULL, will be set to current measure length in beats (i.e. time signature numerator)
// if fullbeats is non-NULL, and measures is non-NULL, fullbeats will get the full beat count (same value returned if measures is NULL).
// if cdenom is non-NULL, will be set to the current time signature denominator.
REAPERAPI_DECL double (*TimeMap2_timeToBeats)(ReaProject* proj, double tpos, int* measures, int* cml, double* fullbeats, int* cdenom);

// converts project time position to QN position.
REAPERAPI_DECL double (*TimeMap2_timeToQN)(ReaProject* proj, double tpos);

// get the effective BPM at the time (seconds) position (i.e. 2x in /8 signatures)
REAPERAPI_DECL double (*TimeMap_GetDividedBpmAtTime)(double time);

// converts project QN position to time.
REAPERAPI_DECL double (*TimeMap_QNToTime)(double qn);

// converts project QN position to time.
REAPERAPI_DECL double (*TimeMap_timeToQN)(double qn);

REAPERAPI_DECL double (*Track_GetPeakInfo)(MediaTrack* tr, int chidx);

REAPERAPI_DECL bool (*TrackFX_FormatParamValue)(MediaTrack* tr, int fx, int param, double val, char* buf, int buflen);

REAPERAPI_DECL int (*TrackFX_GetCount)(MediaTrack* tr);

REAPERAPI_DECL bool (*TrackFX_GetFXName)(MediaTrack* tr, int fx, char* buf, int buflen);

REAPERAPI_DECL int (*TrackFX_GetNumParams)(MediaTrack* tr, int fx);

REAPERAPI_DECL double (*TrackFX_GetParam)(MediaTrack* tr, int fx, int param, double* minval, double* maxval);

REAPERAPI_DECL bool (*TrackFX_GetParamName)(MediaTrack* tr, int fx, int param, char* buf, int buflen);

REAPERAPI_DECL bool (*TrackFX_SetParam)(MediaTrack* tr, int fx, int param, double val);

REAPERAPI_DECL void (*TrackList_AdjustWindows)(bool isMajor);

REAPERAPI_DECL void (*TrackList_UpdateAllExternalSurfaces)();

// call to start a new block
REAPERAPI_DECL void (*Undo_BeginBlock)();

// call to start a new block
REAPERAPI_DECL void (*Undo_BeginBlock2)(void* proj);

// returns string of next action,if able,NULL if not
REAPERAPI_DECL const char* (*Undo_CanRedo2)(void* proj);

// returns string of last action,if able,NULL if not
REAPERAPI_DECL const char* (*Undo_CanUndo2)(void* proj);

// nonzero if success
REAPERAPI_DECL int (*Undo_DoRedo2)(void* proj);

// nonzero if success
REAPERAPI_DECL int (*Undo_DoUndo2)(void* proj);

// call to end the block,with extra flags if any,and a description
REAPERAPI_DECL void (*Undo_EndBlock)(const char* descchange, int extraflags);

// call to end the block,with extra flags if any,and a description
REAPERAPI_DECL void (*Undo_EndBlock2)(void* proj, const char* descchange, int extraflags);

// limited state change to items
REAPERAPI_DECL void (*Undo_OnStateChange)(const char* descchange);

// limited state change to items
REAPERAPI_DECL void (*Undo_OnStateChange2)(void* proj, const char* descchange);

REAPERAPI_DECL void (*Undo_OnStateChange_Item)(ReaProject* proj, const char* name, MediaItem* item);

// trackparm=-1 by default,or if updating one fx chain,you can specify track index
REAPERAPI_DECL void (*Undo_OnStateChangeEx)(const char* descchange, int whichStates, int trackparm);

// trackparm=-1 by default,or if updating one fx chain,you can specify track index
REAPERAPI_DECL void (*Undo_OnStateChangeEx2)(void* proj, const char* descchange, int whichStates, int trackparm);

REAPERAPI_DECL void (*UpdateItemInProject)(MediaItem* item);

REAPERAPI_DECL void (*UpdateTimeline)();

// returns true if the pointer is a valid object of the right type
REAPERAPI_DECL bool (*ValidatePtr)(void* pointer, const char* ctypename);

REAPERAPI_DECL bool (*WDL_VirtualWnd_ScaledBlitBG)(LICE_IBitmap* dest, WDL_VirtualWnd_BGCfg* src, int destx, int desty, int destw, int desth, int clipx, int clipy, int clipw, int cliph, float alpha, int mode);

#endif // _REAPER_PLUGIN_FUNCTIONS_H_

